# -*- coding: utf-8 -*-
"""Untitled35.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1NZq2EAr448D-kGaKW_6QmVX7s1ljWs-T
"""

#03ex_numberRepresentation_es01.py
def binary (to_bin):
    bin_2_bin = bin(to_bin)
    print("binary :" , bin_2_bin)
    
def decimal (number):
    bin_num = int(number)
    print("decimal :" , bin_num)
    
def hexa (to_hex):
    to_hex = hex(to_hex)
    print("hexadecimal :", to_hex)

to_bin = 0x59c
binary(to_bin)
to_bin = 365
binary(to_bin)

number = 0x147b
decimal (number)
number = 0b0101010101
decimal(number)

to_hex= 0b10101010
hexa(to_hex)
to_hex = 89
hexa(to_hex)

#03ex_numberRepresentation_es02.py
x = input()
def convertor(x):
    if x[0] == 0:
        sign = 1
    else:
        sign = -1

    exp  = int('0b' + x[1:9], 2)
    mant = int('0b' + x[9:], 2) / (2 ** 23)

    print("Decimal no will be: ", sign * (1 + mant) * 2**(exp - 127))

convertor(x)

#03ex_numberRepresentation_es03.py
underflow = 1
overflow = 1
for i in range(512):
    underflow = underflow / 2
    overflow = overflow * 2
underflow_ = "{:e}".format(underflow)
overflow_ = "{:e}".format(overflow)
print("overflow:", overflow_)
print("underflow:", underflow_)

#03ex_numberRepresentation_es04.py

def findPrecision(init, precision):
    while (init + precision != init):
        precision = precision/2
       
    return precision

print(findPrecision(1,0.1))
init =1
precision = 0.1

print("machine precision  ", str(findPrecision(init,precision)))

#03ex_numberRepresentation_es05.py
import math
import cmath
a = 0.001
b = 1000
c = 0.001
d = float((b**2) - (4*a*c)) 
ans1 = (-b - math.sqrt(d))/(2*a)  
ans2 = (-b+math.sqrt(d))/(2*a)  
print(f'solutions {ans1} and {ans2}') 

#B
d = float((b**2) - (4*a*c))  
multi1 = (-b + cmath.sqrt(d))
multi2 = (-b - cmath.sqrt(d))
sol1 = ((-b - cmath.sqrt(d)) *multi1) /((2*a) * multi1)  
sol2 = ((-b+cmath.sqrt(d))* multi1)/((2*a) *multi2)

print(f'solutions {ans1} and {ans2}' , 'we have same answer in parts a & b.') 
#we have same answer in parts a & b.

#C
def quad(a,b,c):
    d = float((b**2) - (4*a*c)) 
    if d > 0:
        roots = 2
        x1 = (((-b) + math.sqrt(d))/(2*a))     
        x2 = (((-b) - math.sqrt(d))/(2*a))
        print(f'2 roots: {x1} and {x2}')
    elif d == 0:
        roots = 1
        x = (-b) / 2*a
        print(f'one root: {x}')
    else:
        roots = 0

quad(0.001,1000,0.001)

#03ex_numberRepresentation_es06.py

def f(x):
    return x*(x-1)

x=1
y = [-2, -4, -6, -8, -10, -12, -14, -16]
for i in y:
	delta = float(10**(i))

	derivative = (f(x+delta)-f(x))/(delta)
	print( i, derivative)
 
 # for smaller values of delta gives good results.

#03ex_numberRepresentation_es07.py