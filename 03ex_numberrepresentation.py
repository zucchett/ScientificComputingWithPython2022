# -*- coding: utf-8 -*-
"""03ex_numberRepresentation.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1xVkQharew7TbCepRLv3GOkZH29bqWeNW

ex1

convert function get 3 inputs:
convertFrom is the system that we want to convert it can be (bin[binary],dec[decimal] and hex[hexadecimal]
convertTo variable determine to output format it can be (bin[binary],dec[decimal] and hex[hexadecimal]
number variable save the value that we want to convert it.
then according to our confertFrom and convertTo variable the convert function call appropriate function for that and return the final value in format that we want.
"""

import math
def convert(): 
  convertFrom=input('enter the input type between bin, dec, and hex')
  convertTo=input('enter the output type between bin, dec, and hex')
  number=input('enter the you number')
  def decTobin(number):
    if (convertFrom=='dec' and convertTo=='bin'):
      num=int(number)
      if num >= 1:
        decTobin(num // 2)
      print(num % 2, end = '')
  decTobin(number)
  def binTodec(number):
    if (convertFrom=='bin' and convertTo=='dec'):
      num = int(number);
      dec_value = 0;
      base = 1;
      temp = num;
      while(temp):
          last_digit = temp % 10;
          temp = int(temp / 10); 
          dec_value += last_digit * base;
          base = base * 2;
    return dec_value;
  if (convertFrom=='bin' and convertTo=='dec'):
    print(binTodec(int(number)));
  def binToHexa(n):
    if (convertFrom=='bin' and convertTo=='hex'):
      binary = int(n)
      temp = 0
      c = 1
      count = 1
      hexn = ['0'] * 100   
      i = 0
      while binary != 0:
          rem = binary % 10
          temp = temp + (rem*c)
          if count % 4 == 0:
              if temp < 10:
                  hexn[i] = chr(temp+48)
              else:
                  hexn[i] = chr(temp+55)
              c = 1
              temp = 0
              count = 1
              i = i+1
          else:
              c = c*2
              count = count+1
          binary = int(binary/10)
      if count != 1:
          hexn[i] = chr(temp+48)  
      if count == 1:
          i = i-1    
      print("\n".format(n), end="")
      while i >= 0:
          print(end=hexn[i])
          i = i-1
  if (convertFrom=='bin' and convertTo=='hex'):
    binToHexa(str(number))
        
  def hexTobin(s):
    if (convertFrom=='hex' and convertTo=='bin'):
      i=str(s)
      n = int(s, 16) 
      plus = ''
      while n > 0:
        plus = str(n % 2) + plus
        n = n >> 1    
      res = plus
      print(str(res))
  if (convertFrom=='hex' and convertTo=='bin'):
    hexTobin(str(number))
  def decTohex(d):
      if (convertFrom=='dec' and convertTo=='hex'):
        dict = {0: '0', 1: '1', 2: '2', 3: '3', 4: '4',
                    5: '5', 6: '6', 7: '7',
                    8: '8', 9: '9', 10: 'A', 11: 'B', 12: 'C',
                    13: 'D', 14: 'E', 15: 'F'}
        hexadecimal = ''
        while(d > 0):
          remainder = d % 16
          hexadecimal = dict[remainder] + hexadecimal
          d = d // 16
        return hexadecimal
  if (convertFrom=='dec' and convertTo=='hex'):
    decimal_number = int(number)
    print( decTohex(decimal_number))
  def hexTodec(d):
      if (convertFrom=='hex' and convertTo=='dec'):
        hex =number 
        c = counter = i = 0 
        size = len(hex) - 1
        while size >= 0:
          if hex[size] >= '0' and hex[size] <= '9':
            rem = int(hex[size])
 
          elif hex[size] >= 'A' and hex[size] <= 'F':
            rem = ord(hex[size]) - 55
 
          elif hex[size] >= 'a' and hex[size] <= 'f':
            rem = ord(hex[size]) - 87
          else:
            c = 1
            break
          counter = counter + (rem * (16 ** i))
          size = size - 1
          i = i+1
      print( counter)
  if (convertFrom=='hex' and convertTo=='dec'):
    hexTodec(number)
convert()

"""ex2"""

def toDec(mantissa):
	exp = -1
	number = 0
	for i in mantissa:
		number += (int(i) * pow(2, exp))
		exp -= 1
	return (number + 1)
if __name__ == "__main__":
	def calculate():
		x=input('enter your umber in IEEE format')
		sign_bit = int(x[0])
		exponent_bias = int(x[2 : 10], 2)
		exponent_unbias = exponent_bias - 127
		mantissa = x[11 : ]
		number = toDec(mantissa)
		real_no = pow(-1, sign_bit) * number * pow(2, exponent_unbias)
		print(real_no)
calculate()
#example x=	'1|10000000|00100010000000010000011' the answer -2.2656562328338623

"""ex 3
sys.float_info.dig shows the maximum number of decimal digits that can be faithfully represented in a float; see below.
"""

import sys
x=1
y=1
counter=0
maximum = sys.float_info.dig 
print(maximum)
i=0
while i<= maximum:
  x=x  * 2
  y=y/2
  i=i+1
  counter+=1
print(x)
print(y)
print(counter)

6e-4

"""ex 4
after few iteration it doesnot change ...
"""

x=1
y=1
i=1
#using small number to add 3e-4 is equal to 0.0006
g=6e-4
while i<9:
  x=x+g
  g=g**3
  diff=(y-x)
  i+=1
  print(diff)

"""ex 5"""

t='''from math import sqrt
def Quadratic():
  a = float(input("enter a"))
  b = float(input("enter b "))
  c = float(input("enter c "))
  x = -b
  d = (b ** 2) - 4 * a * c
  if d > 0:
     u = d ** 0.5
     x1 = float(-b + u / 2*a)
     x2 = float(-b - u / 2*a)
     return "There are 2 roots: %2f and %2f" % (x1, x2)
  elif d < 0:
     return "There is no such root with Real value."
  elif d == 0 :
      u = d ** 0.5
      x1 = -b + u / 2*a
      return "There is just one root: %f" % (x1)
Quadratic()'''

"""ex 6
a:
"""

def func(x):
  return  x * (x-1)
print(func(int(input("enter x"))))
def func2(x):
  return (2*x)-1
print(func2(int(input("enter x"))))

"""ex 6
b:

the answer for this is one but when we put delta to 0.01 and fewer value like 0.001 or 0.000001 we get more accurate answer
"""

from sympy import limit 
delta = 0.01
x = 1
if delta == 0:
  Function = x * (x-1)
else:
  Function = ((x + delta) * (x + delta - 1)) - (x * (x-1))
y =  Function / delta
limit(y, x, 0)

from sympy import limit 
def limitCalculate(delta,num):
  if delta == 0:
    Function = x * (num-1)
  else:
    Function = (num + delta) * (num + delta - 1)
  y =  Function / delta
  return limit(y, num, 0)

#when delta is 0.01
limitCalculate(0.01,1)

#when delta is 0.001
limitCalculate(0.001,1)

#when delta is 0.0000001 is closer to 1 and we have accurate answer
limitCalculate(0.0000001,1)

"""ex 7
a:
"""

import math 
def integral(x):
    u = 1
    l = -1  
    h = (u - l) / x
    I = 0 
    for k in range(x):
        x = l + h * k
        ret = math.sqrt(1 - x**2)
        I += h * ret
    return I
    
print(integral(100))
print(math.pi/2)

"""ex 7 
b:
"""

import math
import timeit
start = timeit.default_timer()


N = 4000000
integral(N)
finish = timeit.default_timer()
print( finish - start)

"""we should reduce n to reach 1 second"""

start = timeit.default_timer()


N = 310000
integral(N)
finish = timeit.default_timer()
print( finish - start)

start = timeit.default_timer()


N = 190000000
integral(N)
finish = timeit.default_timer()
print( finish - start)

"""we should reduce n to reach 60 s"""

start = timeit.default_timer()


N = 178000000
integral(N)
finish = timeit.default_timer()
print( finish - start)