# -*- coding: utf-8 -*-
"""04ex_numpy.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1G8_7uJKtawx3g7Y5stoe8E5jc2x9LMKE
"""

# import naming convention

import numpy as np
from numpy import newaxis
import pylab
from pylab import *
import timeit
import numpy.random as npr
import matplotlib.pyplot as plt
import math
from math import pow, ceil

#NUMBER 1: REDUCTION EXERCISE

m = np.arange(12).reshape((3, 4))
print("Overall:", m.mean())
print("Row: ", m.mean(0))
print("Column: ", m.mean(1))

#NUMBER 2: OUTER PRODUCT EXERCISE


u = np.array([1, 3, 5, 7])
v = np.array([2, 4, 6, 8])
print(u)
print(v)
print("Using the function outer in numpy:")
print(np.outer(u, v))
print("Using list or loop comprehension:")
print([m * n for m in u for n in v])
print("Using numpy broadcasting operations:")
print(u[:, newaxis] * v)

#NUMBER 3: MATRIX MASKING EXERCISE


matrix = 3 * npr.random_sample((10, 6)) - 0
print("10 * 6 Matrix of float random numbers, distributed between 0 and 3: ")
print(matrix)
arr = np.array(matrix)
mask = (matrix < 0.3)
print("Mask: \n", mask)
matrix[matrix < 0.3] = 0
print("\n All entries smaller than 3 set to zero using a mask: ")
print(matrix)

#NUMBER 4: TRIGONOMETRIC FUNCTIONS EXERCISE

array = np.linspace(0, 2*math.pi, num=100)
print("A linear space containing 100 values between 0 and 2*pi (inclusive):\n", array)
print("\n Each 10th element was extracted using slice notation:\n", array[::10])
print("\n Slice notation was used to reverse the array:\n", array[::-1])
elements = np.abs(np.sin(array)-np.cos(array)) < 0.1
print("\n Elements where the absolute difference between "
      "the sin and cos functions is smaller than 0.1:\n", array[elements])
pylab.title("Graph showing where sin and cos are close together.")
pylab.plot(array, np.sin(array), array, np.cos(array))
pylab.show()

#NUMBER 5: MATRICES EXERCISE

print("10 * 10 matrix multiplication table:")
mt = np.arange(1, 11)
m = mt[:, None] * mt[None, :]
print(m)
print("\n The trace of the matrix: ", m.trace())
print("\n The anti-diagonal matrix: ", np.flipud(m).diagonal())
print("\n The diagonal offset by 1 upwards: ", m.diagonal(offset=1))

#NUMBER 6: BROADCASTING EXERCISE

positions = np.array([0, 198, 303, 736, 871, 1175, 1475, 1544, 1913, 2448])
distance = np.abs(positions - positions[:, np.newaxis])
print("\n Distances between each city:\n", distance)
plt.pcolor(distance)
plt.colorbar()
print("\n This is converted from miles in: \n", distance/0.62137119)

#NUMBER 7: PRIME NUMBERS SIEVE EXERCISE

def sieve(n):
    N = [True for i in range(n+1)]
    N[1] = False
    primes = []
    for i in range(2, ceil(pow(n, 0.5))+1):
        if N[i]:
            for j in range(i*i, n+1, i):
                N[j] = False
    for i in range(2, n+1):
        if N[i]:
           primes.append(i)
    return primes

n = int(input("Enter N: \n"))
print(sieve(n))
print(timeit.timeit('sieve(n)', globals=globals(), number=99))

#NUMBER 8: DIFFUSION USING RANDOM WALK EXERCISE

m = 2 * randint(0, 2, size=(1000, 200))-1
print(m)

w_d = m.sum(1)
print("\n", m.sum(1))

w_d_s = np.square(w_d)
print("\n", w_d_s)

m_d_s = []
mean = 0
for i in w_d_s:
    mean += i
    m_d_s.append(np.mean(mean))
print(m_d_s)

distances = np.sqrt(w_d_s)
m = np.arange(0, len(distances))
plt.plot(m, distances)
plt.show()